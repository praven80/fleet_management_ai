{"version":3,"file":"static/js/557.36e34eb0.chunk.js","mappings":"6IAAO,MAAMA,EAETC,WAAAA,CAAYC,IAAOC,EAAAA,EAAAA,GAAA,qBAEXC,KAAKF,MAAQG,OADI,kBAAVH,GAAsB,MAAOA,EAChBA,EAAMI,EAGNJ,GAExB,MAAMK,EAAqC,kBAApBL,EAAMK,UAAyBL,EAAMK,UAAY,EAKxE,GAJkBA,EAAUC,OAAOC,kBAC/BF,EAAUC,OAAOE,kBACjBC,KAAKC,IAAIL,KAAaM,KACtBL,OAAOM,MAAMP,GAEb,MAAM,IAAIQ,MAAM,kEAADC,OAAmET,EAAO,2BAEjG,CACA,WAAOU,CAAKf,GACR,OAAO,IAAIF,EAAYE,EAC3B,CACAgB,gBAAAA,GACI,MAAO,CACHZ,EAAGF,KAAKe,WAEhB,CACAC,QAAAA,GACI,MAAMC,EAAcjB,KAAKe,WACzB,OAAOG,OAAOD,EAClB,CACAF,QAAAA,GACI,OAAOd,OAAOD,KAAKF,MACvB,CACAK,OAAAA,GACI,OAAOH,KAAKe,UAChB,EClCG,MAAMI,EAAkBA,CAACC,EAAMC,KAClC,IAAK,MAAOC,EAAKxB,KAAUyB,OAAOC,QAAQJ,GACtC,QAAcK,IAAV3B,EACA,OAAQwB,GACJ,IAAK,OACD,OAAO,KACX,IAAK,OACD,OAAOI,QAAQ5B,GACnB,IAAK,IACD,OAAO6B,EAAc7B,EAAOuB,GAChC,IAAK,IACD,OAAOO,EAAc9B,GACzB,IAAK,IACD,OAAO+B,EAAc/B,GACzB,IAAK,IACD,OAAOgC,EAAYhC,EAAOuB,GAC9B,IAAK,IACD,OAAOU,EAAWjC,EAAOuB,GAC7B,IAAK,KACD,OAAO,IAAIW,IAAIlC,EAAMmC,IAAKC,GAASP,EAAcO,EAAMb,KAC3D,IAAK,KACD,OAAO,IAAIW,IAAIlC,EAAMmC,IAAIL,IAC7B,IAAK,KACD,OAAO,IAAII,IAAIlC,EAAMmC,IAAIJ,IAC7B,QACI,MAAM,IAAIlB,MAAM,4BAADC,OAA6BU,IAI5D,MAAM,IAAIX,MAAM,qBAADC,OAAsBuB,KAAKC,UAAUhB,MAElDO,EAAgBA,CAACU,EAAWhB,KAC9B,GAAoC,oBAAlB,OAAPA,QAAO,IAAPA,OAAO,EAAPA,EAASiB,aAChB,OAAc,OAAPjB,QAAO,IAAPA,OAAO,EAAPA,EAASiB,YAAYD,GAEhC,GAAW,OAAPhB,QAAO,IAAPA,GAAAA,EAASiB,YACT,OAAO1C,EAAYiB,KAAKwB,GAE5B,MAAME,EAAMnC,OAAOiC,GACbG,EAAiB,CAACpC,OAAOqC,kBAAmBrC,OAAOsC,mBAEzD,IAD6BH,EAAMnC,OAAOC,kBAAoBkC,EAAMnC,OAAOE,oBAAsBkC,EAAeG,SAASJ,GAChG,CACrB,GAAsB,oBAAXrB,OASP,MAAM,IAAIP,MAAM,GAADC,OAAIyB,EAAS,kFAR5B,IACI,OAAOnB,OAAOmB,EAClB,CACA,MAAOO,GACH,MAAM,IAAIjC,MAAM,GAADC,OAAIyB,EAAS,+EAChC,CAKR,CACA,OAAOE,GAELV,EAAiBZ,GAAgBA,EACjCW,EAAiBiB,GAAgBA,EACjCf,EAAcA,CAACgB,EAAMzB,IAAYyB,EAAKb,IAAKC,GAASf,EAAgBe,EAAMb,IAC1EU,EAAaA,CAACE,EAAKZ,IAAYE,OAAOC,QAAQS,GAAKc,OAAO,CAACC,EAAGC,KAAA,IAAG3B,EAAKxB,GAAMmD,EAAA,OAAOD,EAAI1B,GAAOH,EAAgBrB,EAAOuB,GAAW2B,GAAM,CAAC,GC3DhIE,EAAaA,CAAC9B,EAAMC,IAClB,OAAPA,QAAO,IAAPA,GAAAA,EAAS8B,yBACFhC,EAAgBC,EAAMC,GAE1BF,EAAgB,CAAEiC,EAAGhC,GAAQC,E","sources":["../node_modules/@aws-sdk/util-dynamodb/dist-es/NumberValue.js","../node_modules/@aws-sdk/util-dynamodb/dist-es/convertToNative.js","../node_modules/@aws-sdk/util-dynamodb/dist-es/unmarshall.js"],"sourcesContent":["export class NumberValue {\n    value;\n    constructor(value) {\n        if (typeof value === \"object\" && \"N\" in value) {\n            this.value = String(value.N);\n        }\n        else {\n            this.value = String(value);\n        }\n        const valueOf = typeof value.valueOf() === \"number\" ? value.valueOf() : 0;\n        const imprecise = valueOf > Number.MAX_SAFE_INTEGER ||\n            valueOf < Number.MIN_SAFE_INTEGER ||\n            Math.abs(valueOf) === Infinity ||\n            Number.isNaN(valueOf);\n        if (imprecise) {\n            throw new Error(`NumberValue should not be initialized with an imprecise number=${valueOf}. Use a string instead.`);\n        }\n    }\n    static from(value) {\n        return new NumberValue(value);\n    }\n    toAttributeValue() {\n        return {\n            N: this.toString(),\n        };\n    }\n    toBigInt() {\n        const stringValue = this.toString();\n        return BigInt(stringValue);\n    }\n    toString() {\n        return String(this.value);\n    }\n    valueOf() {\n        return this.toString();\n    }\n}\n","import { NumberValue } from \"./NumberValue\";\nexport const convertToNative = (data, options) => {\n    for (const [key, value] of Object.entries(data)) {\n        if (value !== undefined) {\n            switch (key) {\n                case \"NULL\":\n                    return null;\n                case \"BOOL\":\n                    return Boolean(value);\n                case \"N\":\n                    return convertNumber(value, options);\n                case \"B\":\n                    return convertBinary(value);\n                case \"S\":\n                    return convertString(value);\n                case \"L\":\n                    return convertList(value, options);\n                case \"M\":\n                    return convertMap(value, options);\n                case \"NS\":\n                    return new Set(value.map((item) => convertNumber(item, options)));\n                case \"BS\":\n                    return new Set(value.map(convertBinary));\n                case \"SS\":\n                    return new Set(value.map(convertString));\n                default:\n                    throw new Error(`Unsupported type passed: ${key}`);\n            }\n        }\n    }\n    throw new Error(`No value defined: ${JSON.stringify(data)}`);\n};\nconst convertNumber = (numString, options) => {\n    if (typeof options?.wrapNumbers === \"function\") {\n        return options?.wrapNumbers(numString);\n    }\n    if (options?.wrapNumbers) {\n        return NumberValue.from(numString);\n    }\n    const num = Number(numString);\n    const infinityValues = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];\n    const isLargeFiniteNumber = (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) && !infinityValues.includes(num);\n    if (isLargeFiniteNumber) {\n        if (typeof BigInt === \"function\") {\n            try {\n                return BigInt(numString);\n            }\n            catch (error) {\n                throw new Error(`${numString} can't be converted to BigInt. Set options.wrapNumbers to get string value.`);\n            }\n        }\n        else {\n            throw new Error(`${numString} is outside SAFE_INTEGER bounds. Set options.wrapNumbers to get string value.`);\n        }\n    }\n    return num;\n};\nconst convertString = (stringValue) => stringValue;\nconst convertBinary = (binaryValue) => binaryValue;\nconst convertList = (list, options) => list.map((item) => convertToNative(item, options));\nconst convertMap = (map, options) => Object.entries(map).reduce((acc, [key, value]) => ((acc[key] = convertToNative(value, options)), acc), {});\n","import { convertToNative } from \"./convertToNative\";\nexport const unmarshall = (data, options) => {\n    if (options?.convertWithoutMapWrapper) {\n        return convertToNative(data, options);\n    }\n    return convertToNative({ M: data }, options);\n};\n"],"names":["NumberValue","constructor","value","_defineProperty","this","String","N","valueOf","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","Math","abs","Infinity","isNaN","Error","concat","from","toAttributeValue","toString","toBigInt","stringValue","BigInt","convertToNative","data","options","key","Object","entries","undefined","Boolean","convertNumber","convertBinary","convertString","convertList","convertMap","Set","map","item","JSON","stringify","numString","wrapNumbers","num","infinityValues","POSITIVE_INFINITY","NEGATIVE_INFINITY","includes","error","binaryValue","list","reduce","acc","_ref","unmarshall","convertWithoutMapWrapper","M"],"ignoreList":[],"sourceRoot":""}